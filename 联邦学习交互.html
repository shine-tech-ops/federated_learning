<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flower 联邦学习交互式解读</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Soothing Neutrals & Warm Accents -->
    <!-- Application Structure Plan: A narrative, single-page application that guides the user from a high-level concept to an interactive process flow, and finally to a summary of responsibilities. The core is an interactive HTML/CSS diagram where users can click steps to reveal details and code snippets, making the learning process engaging and self-paced. This structure is chosen over a static document to actively involve the developer in understanding the Flower framework's internal logic and their role within it. -->
    <!-- Visualization & Content Choices: 1. Main Process: Interactive Flow Diagram (HTML/CSS) to visualize the server-client communication loop. Goal: Organize/Explain. Justification: Interactive exploration is better than static text for a process. 2. Responsibilities: Side-by-side card layout (HTML/CSS) to replace the summary table. Goal: Compare. Justification: Visually separates concerns more effectively than a table. 3. Code Snippets: Styled code blocks with copy-to-clipboard functionality (JS). Goal: Inform. Justification: Improves usability for the developer audience. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #fdfdfd;
            color: #333;
        }
        .accent-color { color: #c084fc; }
        .accent-bg { background-color: #c084fc; }
        .accent-border { border-color: #c084fc; }
        .section-title {
            font-size: 2.25rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 1rem;
        }
        .section-subtitle {
            font-size: 1.125rem;
            color: #6b7280;
            text-align: center;
            max-width: 48rem;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 3rem;
        }
        .flow-step {
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .flow-step.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(192, 132, 252, 0.5);
            border-color: #c084fc;
        }
        .flow-arrow {
            font-size: 2.5rem;
            color: #d1d5db;
            line-height: 1;
            margin: 0.5rem 0;
            text-align: center;
        }
        .code-block {
            background-color: #282c34;
            color: #abb2bf;
            border-radius: 0.5rem;
            padding: 1rem;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            overflow-x: auto;
            position: relative;
        }
        .copy-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4b5563;
            color: #e5e7eb;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #6b7280;
        }
        .flowchart-layer-container {
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.05);
        }
        .layer-central {
            background-color: #f0f9ff; /* Light Blue */
            border: 2px solid #90cdf4;
        }
        .layer-agg {
            background-color: #f5f3ff; /* Light Purple */
            border: 2px solid #b794f4;
        }
        .layer-edge {
            background-color: #f0fff4; /* Light Green */
            border: 2px solid #9ae6b4;
        }
    </style>
</head>
<body class="antialiased">

    <main class="container mx-auto px-4 py-12 md:py-20">

        <section id="hero" class="text-center mb-20 md:mb-32">
            <h1 class="text-4xl md:text-6xl font-extrabold mb-4">Flower 联邦学习</h1>
            <h2 class="text-2xl md:text-4xl font-semibold accent-color mb-6">模型下发与聚合机制解读 (三层架构)</h2>
            <p class="max-w-3xl mx-auto text-lg md:text-xl text-gray-600">
                Flower 已经为您实现了复杂的底层通信与数学逻辑。本应用将通过交互式图解，带您深入理解其核心工作原理，特别是如何在一个分层的联邦学习架构中实现模型下发与聚合，以及您在其中扮演的关键角色。
            </p>
        </section>

        <section id="interactive-flow" class="mb-20 md:mb-32">
            <h3 class="section-title">一个训练轮次的完整旅程：三层协作</h3>
            <p class="section-subtitle">
                在三层联邦学习架构中，中央服务器、聚合服务器和边缘节点协同工作，完成模型的迭代训练。点击下方流程中的任意一步，即可查看该环节的详细说明、工作原理以及您需要编写的关键代码。
            </p>

            <div class="flex flex-col space-y-8 items-center justify-center max-w-4xl mx-auto">
                <!-- 中央服务器层 -->
                <div class="w-full flowchart-layer-container layer-central">
                    <div class="text-xl font-bold mb-4 text-blue-700 text-center">中央服务器 (Central Server)</div>
                    <div id="step-central-1" class="flow-step bg-white p-6 rounded-lg border-2 border-transparent w-full flex items-center justify-center text-center h-32">
                        <p class="text-lg font-semibold">1. 发布全局任务 &<br>接收局部聚合模型</p>
                    </div>
                </div>
                <div class="flow-arrow text-blue-500">↓</div>

                <!-- 聚合服务器层 -->
                <div class="w-full flowchart-layer-container layer-agg">
                    <div class="text-xl font-bold mb-4 text-purple-700 text-center">聚合服务器 (Aggregation Server)</div>
                    <div id="step-agg-1" class="flow-step bg-white p-6 rounded-lg border-2 border-transparent w-full flex items-center justify-center text-center h-32">
                        <p class="text-lg font-semibold">2. 接收全局任务 &<br>分发至边缘节点</p>
                    </div>
                    <div class="flow-arrow text-purple-500 mt-4 mb-4">↓</div>
                    <div id="step-agg-2" class="flow-step bg-white p-6 rounded-lg border-2 border-transparent w-full flex items-center justify-center text-center h-32">
                        <p class="text-lg font-semibold">4. 收集边缘节点更新 &<br>执行局部聚合</p>
                    </div>
                </div>
                <div class="flow-arrow text-purple-500">↑</div>

                <!-- 边缘节点层 -->
                <div class="w-full flowchart-layer-container layer-edge">
                    <div class="text-xl font-bold mb-4 text-green-700 text-center">边缘节点 (Edge Node)</div>
                    <div id="step-edge-1" class="flow-step bg-white p-6 rounded-lg border-2 border-transparent w-full flex items-center justify-center text-center h-32">
                        <p class="text-lg font-semibold">3. 接收任务 &<br>本地训练</p>
                    </div>
                </div>
            </div>

            <div id="details-panel" class="mt-12 bg-white p-8 rounded-xl shadow-2xl border border-gray-200 transition-opacity duration-500 opacity-0 max-h-0 overflow-hidden">
                <h4 id="details-title" class="text-2xl font-bold mb-4 accent-color"></h4>
                <div id="details-content" class="text-gray-700"></div>
            </div>
        </section>

        <section id="responsibilities" class="mb-20 md:mb-32">
            <h3 class="section-title">职责划分：Flower 与您</h3>
            <p class="section-subtitle">
                理解框架和开发者之间的职责分工是高效开发的关键。Flower 负责繁重的“管道”工作，而您则专注于“管道”中流动的“水”——也就是您的模型和数据逻辑。
            </p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-6xl mx-auto">
                <div class="bg-purple-50 border-2 accent-border rounded-lg p-8 shadow-lg">
                    <h4 class="text-2xl font-bold mb-4 text-center">⚙️ Flower 的职责</h4>
                    <ul class="space-y-4">
                        <li class="p-4 bg-white rounded-md shadow">
                            <h5 class="font-bold text-lg">模型下发</h5>
                            <p class="text-gray-600">通过底层 gRPC 网络通信，将序列化后的模型参数和训练指令安全地发送给选定的客户端。</p>
                        </li>
                        <li class="p-4 bg-white rounded-md shadow">
                            <h5 class="font-bold text-lg">模型聚合</h5>
                            <p class="text-gray-600">在服务器端 `Strategy` 中提供核心聚合算法（如 FedAvg），收集并处理所有客户端返回的模型更新。</p>
                        </li>
                    </ul>
                </div>
                <div class="bg-gray-100 border-2 border-gray-300 rounded-lg p-8 shadow-lg">
                    <h4 class="text-2xl font-bold mb-4 text-center">👩‍💻 您的职责</h4>
                    <ul class="space-y-4">
                        <li class="p-4 bg-white rounded-md shadow">
                            <h5 class="font-bold text-lg">实现 `fit` 方法</h5>
                            <p class="text-gray-600">在客户端的 `fit` 方法中接收参数，用 `model.set_weights()` 更新本地模型，执行训练，并返回更新后的参数。</p>
                        </li>
                        <li class="p-4 bg-white rounded-md shadow">
                            <h5 class="font-bold text-lg">选择或自定义 `Strategy`</h5>
                            <p class="text-gray-600">在服务器端选择并配置一个合适的 `Strategy`，或继承它来添加日志、历史记录等自定义功能。</p>
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="conclusion" class="text-center">
             <h3 class="section-title">结论：高速公路与汽车</h3>
            <p class="section-subtitle">
                请放心，您不需要从零开始构建这些复杂的联邦学习流程。<br>Flower 已经为您铺好了<span class="accent-color font-bold">高速公路</span>，您只需要驾驶您的<span class="accent-color font-bold">“模型汽车”</span>在上面行驶即可，专注于您的模型训练逻辑和策略的自定义。
            </p>
             <div class="text-6xl">🚗💨🛣️</div>
        </section>

    </main>

    <script>
        const steps = {
            "step-central-1": {
                title: "第 1 步：中央服务器：发布全局任务与最终聚合",
                content: `
                    <p class="mb-4">作为联邦学习架构的顶层，**中央服务器**负责协调整个训练过程的全局视图。它会发布当前轮次的全局训练任务（包含最新全局模型），将任务发送给注册的**聚合服务器**。同时，它也负责接收来自所有聚合服务器的局部聚合模型，并执行最终的全局模型聚合，更新全局模型。</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>发布任务</strong>: 中央服务器从文件存储或缓存加载最新全局模型，通过消息队列或直接通信方式，将任务分发给各聚合服务器。</li>
                        <li><strong>最终聚合</strong>: 收集来自聚合服务器的局部聚合模型，执行最终的聚合算法（如加权平均），生成新的全局模型，并持久化到文件存储和更新缓存。</li>
                    </ul>
                    <h5 class="font-semibold text-lg mb-2">您需要做什么？</h5>
                    <p class="mb-4">在中央服务器端，您通常会配置一个根 \`Strategy\` (如 \`FedAvg\`) 来管理全局聚合逻辑和与聚合服务器的交互。虽然代码示例与聚合服务器类似，但其操作对象是更高级别的聚合模型。</p>
                    <div class="code-block" id="code-central-1">
<button class="copy-button" onclick="copyCode('code-central-1')">复制</button><pre><code># 在中央服务器的 flower_server.py 中
# 配置并启动中央服务器，其 Strategy 负责与聚合服务器交互
strategy = fl.server.strategy.FedAvg(
    # ... 配置聚合策略 ...
)
fl.server.start_server(strategy=strategy, ...)
</code></pre>
                    </div>`
            },
            "step-agg-1": {
                title: "第 2 步：聚合服务器：接收全局任务并分发至边缘节点",
                content: `
                    <p class="mb-4">**聚合服务器**是中央服务器和边缘节点之间的中间层。它接收来自**中央服务器**的全局训练任务，并将其转换为适合其管辖的**边缘节点**执行的局部任务，然后分发。</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>接收全局任务</strong>: 聚合服务器通过消息队列或直接连接接收中央服务器发来的全局模型和训练配置。</li>
                        <li><strong>分发局部任务</strong>: 聚合服务器会选择其下属的边缘节点，并使用 Flower 的通信机制将模型和任务指令发送给这些边缘节点。</li>
                    </ul>
                    <h5 class="font-semibold text-lg mb-2">您需要做什么？</h5>
                    <p class="mb-4">聚合服务器通常也运行一个 Flower 服务器实例，但其策略配置可能针对其管辖的边缘节点。您需要确保其能够接收来自中央服务器的任务，并向边缘节点正确下发。</p>
                    <div class="code-block" id="code-agg-1">
<button class="copy-button" onclick="copyCode('code-agg-1')">复制</button><pre><code># 在聚合服务器的 flower_server.py 中
# 这个服务器实例负责与边缘节点交互
strategy = fl.server.strategy.FedAvg(
    fraction_fit=0.5,  # 例如，选择 50% 的边缘节点
    # ... 其他聚合策略配置 ...
)
fl.server.start_server(strategy=strategy, ...)
</code></pre>
                    </div>`
            },
            "step-edge-1": {
                title: "第 3 步：边缘节点：接收任务与本地训练",
                content: `
                    <p class="mb-4">**边缘节点**是联邦学习最底层的参与者，拥有本地私有数据。它们从**聚合服务器**接收训练任务，并在本地进行模型训练。</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>接收任务</strong>: 边缘节点接收来自其聚合服务器的模型参数和训练配置。</li>
                        <li><strong>本地训练</strong>: 在本地数据集上执行模型训练（例如，几个 epoch），生成新的局部模型更新。</li>
                        <li><strong>返回更新</strong>: 将训练后的局部模型更新（例如，梯度、模型权重）通过 Flower 的通信机制安全地发送回其聚合服务器。</li>
                    </ul>
                    <h5 class="font-semibold text-lg mb-2">您需要做什么？</h5>
                    <p class="mb-4">您需要在客户端（边缘节点）的 <strong>fit</strong> 方法中，接收由 Flower "下发" 来的模型参数，用它来更新您本地的模型，执行训练，然后返回更新后的参数。Flower 会负责将其安全地传回聚合服务器。</p>
                    <div class="code-block" id="code-edge-1">
<button class="copy-button" onclick="copyCode('code-edge-1')">复制</button><pre><code># 在您的客户端代码中 (client.py)
class FlowerClient(fl.client.NumPyClient):
    def fit(self, parameters, config):
        # 1. Flower 将模型参数 \`parameters\` "下发" 到这里 (来自聚合服务器)
        # 2. 您需要做的就是用它来更新本地模型
        self.model.set_weights(parameters)

        # 3. 然后执行本地训练...
        self.model.fit(self.x_train, self.y_train, **config)

        # 4. 返回训练后的新参数，Flower 会负责传回聚合服务器
        return self.model.get_weights(), len(self.x_train), {}
</code></pre>
                    </div>`
            },
            "step-agg-2": {
                title: "第 4 步：聚合服务器：收集边缘节点更新与执行局部聚合",
                content: `
                    <p class="mb-4">**聚合服务器**在收集到其下属**边缘节点**返回的局部模型更新后，执行局部聚合操作，并将结果发送回**中央服务器**。</p>
                    <ul class="list-disc list-inside space-y-2 mb-6">
                        <li><strong>收集结果</strong>: 聚合服务器等待并收集所有参与本轮训练的边缘节点返回的局部模型更新。</li>
                        <li><strong>执行局部聚合</strong>: 聚合服务器端的 \`Strategy\` 会调用其 \`aggregate_fit\` 方法，对这些局部更新进行聚合，生成一个区域性的聚合模型。</li>
                        <li><strong>汇报中央服务器</strong>: 将局部聚合后的模型发送给中央服务器，作为中央服务器进行最终全局聚合的输入。</li>
                    </ul>
                    <h5 class="font-semibold text-lg mb-2">您需要做什么？</h5>
                    <p class="mb-4">在聚合服务器端，您的策略会像标准 Flower 服务器一样，调用 <code>super().aggregate_fit(...)</code> 来触发 Flower 内置的聚合算法。这个聚合的结果将作为其向中央服务器汇报的数据。</p>
                    <div class="code-block" id="code-agg-2">
<button class="copy-button" onclick="copyCode('code-agg-2')">复制</button><pre><code># 在聚合服务器的 flower_server.py 中 (Custom Strategy 示例)
class AggregationServerStrategy(FedAvg):
    def aggregate_fit(self, server_round: int, results: List[Tuple[fl.server.client_proxy.ClientProxy, FitRes]], failures: List[BaseException]):
        # 聚合服务器收集边缘节点结果，并进行局部聚合
        aggregated_parameters, aggregated_metrics = super().aggregate_fit(
            server_round, results, failures
        )
        # 局部聚合完成后，aggregated_parameters 会被发送回中央服务器
        return aggregated_parameters, aggregated_metrics
</code></pre>
                    </div>`
            }
        };

        const detailsPanel = document.getElementById('details-panel');
        const detailsTitle = document.getElementById('details-title');
        const detailsContent = document.getElementById('details-content');
        let activeStep = null;

        document.querySelectorAll('.flow-step').forEach(step => {
            step.addEventListener('click', () => {
                const stepId = step.id;

                if (activeStep) {
                    activeStep.classList.remove('active');
                }

                if (activeStep === step) {
                    detailsPanel.style.opacity = 0;
                    detailsPanel.style.maxHeight = 0;
                    activeStep = null;
                    return;
                }

                step.classList.add('active');
                activeStep = step;

                detailsTitle.textContent = steps[stepId].title;
                detailsContent.innerHTML = steps[stepId].content;

                detailsPanel.style.opacity = 1;
                detailsPanel.style.maxHeight = detailsPanel.scrollHeight + "px";

                detailsPanel.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        });

        function copyCode(codeBlockId) {
            const codeElement = document.getElementById(codeBlockId).querySelector('pre code');
            const textToCopy = codeElement.innerText;

            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);

            const button = document.getElementById(codeBlockId).querySelector('.copy-button');
            const originalText = button.innerText;
            button.innerText = '已复制!';
            setTimeout(() => {
                button.innerText = originalText;
            }, 1500);
        }
    </script>
</body>
</html>
